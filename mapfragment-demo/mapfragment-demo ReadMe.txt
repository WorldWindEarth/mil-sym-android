mapfragment-demo Readme

mapfragment-demo tester on my box is under C:\Android\Rendering and uses google maps and the Renderer library which is under SVN ..\Rendering\Android.
To use google maps you will need the google maps service and your own key in the Android manifest file (look for your-key-here).

If you download from Subversion, then on the initial build you will probably have to replace Rendering/Android/mapfragment-demo/libs/googleplayservices.jar with the jar from your own install folder, or you'll get a link error.

AVD setup
It runs much faster with AVD's which are set to Intel x86 CPU. But to run with these you need HAXM installed and hardware virtualization must be set on your computer. Use Target: Google API's x86 - API level 19. Set SD Card size to 20 MiB to be able to pull the temp.kml from storage at runtime. Select Use Host GPU.

Running the demo
To render a symbol type the 15 character Mil-Std-2525 symbol id or acronym (e.g. flot) at the cursor at the top of the map display. Then click 4 points for regular lines. Shapes requiring a fixed number of anchor points (Autoshapes, e.g. Breach) will display after 4 points or fewer. Pan or zoom as desired using the map control. The symbol refreshes on pans and zooms. To clear the display before rendering another line you can click the menu button.The tester tests RenderWithPolylines to display on the Google Maps background using a GoogleMap (2D) widget. It also tests SECWebRenderer for KML generation for 3D display on the same iteration, so it's calling both functions. To access the KML file at runtime get a command prompt and change directory to android\platform-tools under wherever you did the Android install (mine is under c:\program files (x86)\android-sdk). The internal file generated by the tester will be storage/sdcard/KML/temp.kml. At the prompt type adb pull to wherever you want to some folder, e.g. adb pull storage/sdcard/KML/temp.kml c:\temp. Open the file in a KML viewer, e.g. Google Earth, to view.

Developer Notes.

Most symbols can be rendered as shown in sample code from com.example.utility:
DoubleClickGE for rendering with the GoogleMap widget on the 2D Google Maps background (2D).
DoubleClickSECRenderer for KML generation. All of the symbols will render. However only the 3d airspaces (route, track, polygon, polyarc, radarc, orbit, cylinder) and the Mil-Std-2525 c2G/Aviation/Lines (UAV, LLTR, SAAFR, AC, MRR) exhibit the altitudes and hence a 3d appearance when the KML is displayed.

2D (Draw with GoogleMap widget).
source: com.example.utility.DoubleClickGE.
clipping area is set to the visible region (clipArea). The effect of clipping can be seen on when the user pans and also on zooms.
rev is the Mil-Std-2525 version or USAS. The default is rev C.

Buiding the symbol object:	MilStdSymbol mss = CreateMSS(symbolCode, "0", pts2);
Setting the symbol properties, e.g. line color, fill color, modifiers, can be seen in the CreateMSS function. Most of the guidance for setting symbol attributes and modifiers can be determined from Mil-Std-2525, including setting the modifier distance (AM), azimuth (AN) and altitude (X) arrays. Examples of how to set these arrays are found in CreateMSS.

Rendering the symbol:	
The renderable shape objects are returned in the MilStdsymbol with the following call:
	clsRenderer.renderWithPolylines(mss, converter, clipArea, context); 
Drawing the shape objects with the GoogleMap (map) widget is done with this call: 
        drawShapeInfosGE(mss.getSymbolShapes());
The function extracts the the symbol shapes returned by the renderer into Android Polygons and Polylines which are then added to the map. Note that pattern fill for 8 METOCS requiring it is handled as a GroundOverlay.
Rendering rotatable text is handled with the following call which adds marker objects to the map: 
        drawShapeInfosText(mss.getModifierShapes());

3D (KML Generation).
Source com.example.utility.DoubleClickSECRenderer.
For Mil-Std-2525 symbols the attributes and modifier arrays are set using SparseArrays as shown in the code immediately preceding the line:
            String strRender = sec.RenderSymbol("id", "name", "description", defaultText, controlPtsStr, altitudeMode, scale, rectStr, modifiers, attributes, 0, rev);
As for the 2D analysis above, the modifiers and attributes requrements can be deduced from Mil-Std-2525 or the USAS.
For Airspace symbols the attributes are set using JSON strings as shown in the code immediately preceding the line:
            strCake = sec.Render3dSymbol("name", "id", defaultText, "", "ff0000ff", "", controlPtsStr, acAttributes);
The requirements for setting the Airspace attributes is as follows:
The symbol id is created from the generic name and dashes to length 15, e.g. symbol id for route is "ROUTE----------". The array requirements are as follows:
Route: radius1 AM[0], minalt X[0], maxalt X[1],
Cylinder: radius1 AM[0], minalt X[0], maxalt X[1]
Orbit: radius1 AM[0], minalt X[0], maxalt X[1]
Polygon: minalt X[0], maxalt X[1]
Radarc: radius1 AM[0], radius2 AM[1], leftAzimuth AN[0], rightAzimuth AN[1], minalt X[0], maxalt X[1]
Polyarc:  radius1 AM[0], leftAzimuth AN[0], rightAzimuth AN[1], minalt X[0], maxalt X[1]
Track: for each segment n: radius1 AM[2*n], radius2 AM[2*n+1], minalt X[2*n], maxalt X[2*n+1]
radii and altitudes are in meters, azimuths are in degrees.
At runtime the resultant KML string is parsed to a KML file:
                parseKML.parseLLTR(strCake, coordStrings);
The KML file can be pulled to the user's hard drive per instructions above using adb pull.
Note: for airspaces there is also a 2D rendering (no altitudes used) by the following lines:
                drawSECRendererCoords3d(coordStrings, converter);
which uses Android Polylines and Polygons to display with the map widget as in the 2D analysis.










